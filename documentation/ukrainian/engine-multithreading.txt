ЗАГАЛЬНІ ПЕРЕДУМОВИ. Якщо ці передумови дотримані, модуль виконання та інші повинні працювати належним чином:
1. Потоки з групи потоків A НЕ ПОВИННІ маніпулювати потоками з групи потоків B у будь-який спосіб, за винятком 
випадків зміни стану з "заблокований" на "готовий до виконання" (після цього будь-яка взаємодія заборонена). 
Це правило здебільшого випливає з того факту, що складно і непотрібно намагатися гарантувати, що потоки 
(і, як наслідок, групи потоків) не будуть знищені посеред взаємодії.
2. Потік може бути видалений ТІЛЬКИ виконавцем, який отримав schedule_information_structure після виклику 
планувальника. Це правило гарантує, що новостворена порожня група потоків не буде видалена до того, як до 
неї буде додано перший потік.
3. Модуль A не повинен викликати функцію з Модуля B, утримуючи будь-який м'ютекс. Це єдиний спосіб запобігти 
взаємним блокуванням (тупиковим ситуаціям, deadlocks) через межі модулів. Усередині модуля ви повинні дбати 
про те, щоб існував загальний порядок, в якому можна захоплювати кілька м'ютексів. Це запобігатиме взаємним 
блокуванням всередині окремого модуля.

За своєю суттю, весь рушій виконання призначений бути потокобезпечним, це означає, що кожна функція кожного 
модуля повинна бути реентерабельною. Немає значення, чи вона завершиться успішно, чи з помилкою, єдина вимога 
полягає в тому, що поведінка повинна бути визначеною за будь-яких умов, якщо дотримані передумови. 

Якщо ви помітили, що рушій нестабільний, спробуйте запустити його лише з одним доступним потоком виконання 
(також званим виконавцем). Якщо збої зникли, то проблема, найімовірніше, у коді багатопоточності. З іншого 
боку, якщо збої тривають, то проблема, найімовірніше, в коді самого модуля. Зауважте, однак, що PRTS завжди 
породжує робочі потоки вводу-виводу, тому якщо проблема в коді вводу-виводу, вона проявить себе навіть з одним виконавцем.