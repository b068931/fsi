Я почну з визначення деяких термінів, які я використовую:
- 'FSI' : Інтерпретатор з нуля (From Scratch Interpreter). Це назва всього проєкту.
- 'транслятор' : Програма, яка перетворює текстове представлення програми FSI у бінарний формат.
- 'медіатор' : Назва виконуваного файлу, який завантажує та налаштовує модулі РВ. Ви також можете додавати власні модулі.
- 'Рушій Виконання' або 'РВ' : Список модулів, які поєднують свою логіку для забезпечення виконання програм FSI.
- 'модуль' : Кожен DLL-файл, завантажений медіатором, називається модулем. Модулі є частинами рушія виконання.
- 'інтерпретатор' або 'FSI інтерпретатор' : Комбінація 'медіатора', 'основних' модулів та всіх інших модулів, 
                                            які ви додаєте до рушія виконання. Варто зазначити, що я використовую термін 
                                            'інтерпретатор' спеціально для того, щоб підкреслити той факт, що нативний 
                                            виконуваний файл ніколи не генерується, навіть попри те, що завантажувач 
                                            програми компілює всю програму в машинний код перед її виконанням. 

Загалом, існує кілька типів помилок:
- 'синтаксична помилка' : Помилка, що виникає, коли програма не є синтаксично коректною. Це виявляється транслятором.
- 'логічна помилка' : Помилка, що виникає, коли програма синтаксично коректна, але не має жодного сенсу.
- 'помилка компіляції' : Помилка, що виникає, коли програма синтаксично коректна, але не може бути 
                         скомпільована в машинний код. Найімовірніше, це пов'язано з логічною помилкою в програмі.
- 'помилка часу виконання' : Помилка, що виникає, коли програма синтаксично коректна, скомпільована в машинний код, 
                             але зазнає збою під час виконання. Зазвичай це пов'язано з логічною помилкою, яку можна 
                             виявити лише під час виконання, наприклад, ділення на нуль.
- 'попередження часу виконання' : Охоплює широкий спектр можливих проблем, які можуть виникнути під час виконання, 
                                  але не перешкоджають роботі програми і не призводять до збою рушія. Переважно це 
                                  помилки паралелізму, після яких інтерпретатор може відновитися. Варто зазначити, 
                                  що зазвичай ви взагалі не повинні бачити жодних попереджень, ви можете використовувати 
                                  їх як індикатор того, що рушій виконання нестабільний.
- 'фатальна помилка' : Помилка в самому інтерпретаторі, наприклад, баг у коді РВ. Це також може статися, якщо вашій програмі 
                       вдасться обійти перевірки інтерпретатора. Наприклад, ви можете випадково вгадати якусь адресу пам'яті, 
                       яка технічно належить вашій програмі, але не призначена для доступу. Це може бути, наприклад, адреса 
                       вашого стека. Не всі фатальні помилки можуть видавати діагностичне повідомлення. Але більшість із них 
                       це роблять, ви можете перевірити module_mediator\crash_handle_setup.cpp, щоб побачити, як інтерпретатор 
                       обробляє фатальні помилки. Командний рядок для запуску медіатора виглядає таким чином:

fsi-mediator <файл-дескриптор-модулів> <кількість-виконавців> <бінарний-файл>
- "modules-descriptor-file" - це шлях до файлу, що містить список модулів для завантаження.
- "executors-count" - це кількість виконавців, які будуть створені. Виконавці - це системні потоки, які виконуватимуть вашу програму.
- "binary-file" - це шлях до стисненого бінарного файлу, створеного транслятором.

Приклад: Запустіть ./fsi-mediator engine.mods 4 "..\out.bfsi" з каталогу bin, щоб запустити трансльовану програму. 
Зауважте, що спочатку вам потрібно запустити транслятор, щоб створити бінарний файл. Спочатку медіатор читає файл 
дескриптора модулів, який є простим текстовим файлом, що містить список модулів для завантаження. Цей файл називається 
'engine.mods'. Він також знаходиться в каталозі 'bin', де розташований виконуваний файл медіатора. Ви можете переглянути 
його, щоб побачити, яку функціональність надає кожен модуль, я додав досить багато коментарів у цей файл. Далі медіатор 
отримує стиснений бінарний файл, створений транслятором, розпаковує його, створюючи фактичне бінарне представлення вашої 
програми. Ця програма зберігається як тимчасовий файл, який потім передається завантажувачу програм. За замовчуванням, 
у всіх модулях увімкнено логування, тож ви можете бачити потік виконання програми в консолі. Ваша програма може скористатися 
моделлю багатопоточності, реалізованою в інтерпретаторі. У повній формі вона повинна складатися з 
груп потоків -> потоків -> волокон + делегатів. На даний момент реалізовані лише перші два рівні. 
Групи потоків вважаються межею між різними програмами. Тобто, потоки з різних груп потоків не можуть взаємодіяти. 
Кожна група потоків фактично працює у власному "контексті". Під "контекстом" я маю на увазі всі рядки, модулі, на які є 
посилання, скомпільовані функції тощо. Ваша програма може створити нову групу потоків, продублювавши свій контекст. 
Потоки з груп потоків обираються за циклічним алгоритмом. Потоки - це різні одиниці виконання, які можуть працювати 
паралельно, залежно від кількості виконавців. Потоки організовані всередині своїх груп у чергу з пріоритетами, планувальник 
завжди обирає потік з найвищим пріоритетом. Якщо потік з найвищим пріоритетом не може виконуватися, планувальник обирає наступний 
потік з найвищим пріоритетом. Потоки в одній пріоритетній групі обслуговуються в порядку FIFO. Кожен потік може перебувати в 
одному з таких станів: запуск (startup), виконується (running), готовий до виконання (runnable), заблокований (blocked). 
Волокна (Fibers) призначені бути чимось схожим на стекові співпрограми (stackful coroutines), одночасно може працювати 
лише одне волокно. Делегати (Delegates) призначені бути одноразовими функціями, які мають виконуватися в контексті певного потоку. 
Вся модель є кооперативною, що означає, що інтерпретатор НЕ МОЖЕ витіснити ваші потоки за власним бажанням. 
Ваші потоки повинні або завершити своє виконання, або передати керування інтерпретатору. 

При виклику з вашої програми, функція модуля повинна повернути те, що називається 'результатом виконання'. Який може бути 
одним із наступних: продовжити (continue), перемкнути (switch), завершити (terminate), блокувати (block). Continue означає, 
що інтерпретатор повинен продовжити виконання поточного потоку. Switch передає керування планувальнику. 
Terminate миттєво вбиває поточний потік. Block означає, що ваш потік не може бути обраний для виконання, він також передає 
керування планувальнику. Кожен модуль визначає свою умову для розблокування потоку, модуль PRTS, наприклад, використовує 
це для реалізації операцій вводу-виводу. Повернення невідомого результату виконання є однією з 'фатальних помилок', з якими 
ви можете зіткнутися. РВ завершує роботу, як тільки виявляє, що не залишилося жодних готових до виконання потоків. 
Він також відмовиться запускатися, якщо ви не додасте для нього якесь початкове завдання.
